## grpc 최적화 linux system 테스트
**크게보기**
<div style="overflow-x: auto; white-space: nowrap;">
  <img src="./assets/long.svg" alt="long image">
</div>

![short](./assets/short.svg)


### 요약 
> linux의 환경 변수등 새로운 완전 Pure한 환경에서 테스트를 할 경우에는 `system(), execv()` 두 메소드 400 ~ 600 사이의 안전한 레이턴시를 보여줍니다.     
> 단 여기에서 테스트를 하는 경우는 배포된 서버의 여러 환경이 설정이 되어있는 상태에서 테스트를합니다.


| Method | 평균 (Mean) | 최소 (Min) | 최대 (Max) | 변동폭 (Std) |
| :--- | ---: | ---: | ---: | ---: |
| **system** | 2,100.22 | 1,702.00 | 4,248.00 | 290.89 |
| **execv** | 1,309.81 | 1,049.00 | 4,534.00 | 212.15 |
| **gRPC-uds** | **783.58** | **648.00** | **2,357.00** | **95.20** |
| **gRPC** | 802.14 | 647.00 | 5,047.00 | 143.39 |



### 향상

| 비교 항목 | 평균 개선율 (Mean) | 최소시간 단축 (Min) | 최대시간 단축 (Max) | 안정성 향상 (Std) |
| :--- | :--- | :--- | :--- | :--- |
| **system ➔ execv** | **37.6%** 개선 | **38.4%** 단축 | -6.7% (증가) | **27.1%** 향상 |
| **system ➔ gRPC-uds** | **62.7%** 개선 | **61.9%** 단축 | **44.5%** 단축 | **67.3%** 향상 |



### 정리 
tcp vs uds 는 오직 전송 시간만 줄여준다. 
gRPC의 경우, Protobuf가 데이터를 압축하고 푸는 과정과 HTTP/2 프레임을 만드는 오버헤드가 CPU를 꽤 많이 사용한다. 
- 추가로 리눅스의 TCP Loopback은 이미 최적화가 되어있어 localhost 통신을 감지하면 패킷을 네트워크로 보내지 않고 커널 메모리 내에서 바로 `Bypass`한다.
- 추가로 UDS는 tcp보다 빠른 구간은 연결을 맺는 순간이다. 3-way handshake가 없어서빠르다.
  - 하지만 gRPC는 HTTP/2 기반이라 한 번 연결을 맺으면 그 연결을 끊지 않고 계속 재사용한다. 
  - 따라서 초기 연결 비용 절감 효과를 볼 기회가 별로 없다. 